##verbatim '%' = MuPlugin.mumode

open Prelude
open Extra




let d = "{section"Dependent types" ~label:s_dep}

Polarised {muname}, with its type-based distinction of values and computations, gives an answer to the question of what it means for type to have effects in them: the answer is, they should not exist. If we see the type <%PI x:A, N%> as a generalisation of the type <%A-oN%>, it is clear that <%x%> only stands for values.

The obvious limitation is that even pure computation are ostensibly forbidden in types, preventing proofs by computation which are quite popular in modern dependent-type-theory-based proof assistants~{cite"Boutin1997"}. Another, somewhat separate, issue which is not addressed in this last section is that of the computation {emph"of"} types, which would be necessary to prove, for instance, the equivalence of <%A<+>B%> and <%SIGMA x:1<+>1, <x|{ mu(1.()), A , mu(2.()), B } >%>. The latter will not even be a valid type.

Despite these limitation, this modest proposal for a dependently typed linear logic is already a fairly expressive logic which includes dependent elimination -- as described in Section~{ref_ ss_depelim}.

{subsection"Weak dependent types"}

A first approach to extend linear {muname} or polarised {muname} with dependent types is to leverage the remark that the duplicable context behaves like a natural deduction context. We could therefore define a dependent product <%PI x:A,N%> like in natural deduction. This dependent product would generalise <%!A-oN%> and we would retain a separate, non-dependent, linear arrow <%A-oN%>. Such a system would be along the lines of linear {textsc"lf"}~{cite"Cervesato1996"}, except in sequence calculus form rather than a natural deduction.

There are no particular difficulty with this approach, but it has severe limitations. The most important limitation is that such a system cannot be extended to dependent elimination. The system we propose in this section has a dependent product which generalises the linear arrow. In Section~{ref_ ss_depelim}, we enrich it with dependent elimination.

A key point of our presentation of {muname} so far, is that <%mu alpha,<t|alpha>%> is essentially the same as just <%t%>, this underlies, in particular, our encoding of pattern-matching, and of linear {lambda}-calculus. This is problematic if types depend on linear variables. Indeed, if <%t%> has type <%N%>, which depend on some linear variable <%x%>, we need <%alpha%> to have type <%N^~%> which also depends on <%x%>. But variables have to be split between <%t%> and <%alpha%> so <%x%> can only go on one side of the cut.

This is where the polarised discipline helps: as variables represent only values, we can restrict type to contain values which are harmless in that they cannot perform effects by themselves. So, it is innocuous to allow variable duplication in types. In this proposal, it is manifested by a third context -- usually denoted by a <%theta%> -- in the typing judgement of value, which represents variables accessible from the type, but not from the value.

This new typing context affects principally the identity and cut rules. Indeed another way one can think about the typing context is that it allows variables to have any type.
{displaymath begin array [`C;`Sep(qquad^^qquad);`C] [
  array_line [ Rules.Typing.Dll0.id ; Rules.Typing.Dll0.cut ];
 ]end}
In the cut rule, the variables which are necessary to make sense of the types in <%Gamma%> and <%A%> but occur in the computation <%u%> are kept in the typing context of the value <%t%>. In the identity rule, the duplicable context and the typing context are joined: types do not make a difference between linear and duplicable variables.

The full system is given in Figure~{ref_ f_wdll}. It makes the simplifying hypothesis that the type of duplicable variables does not depend on linear variables. When we write $"<%Gamma%>","<%Delta%>"$, it is implied that types in <%Delta%> may depend on variables of <%Gamma%> but types of <%Gamma%> may not depend on variables of <%Delta%>. Also, all context which appear in the premise of a typing rule is supposed to make sense, hence in the cut and tensor rule, it is understood that <%Gamma%> and <%Delta%> do not depend on each other, and in the introduction rule for <%?A^~%>, the context <%Gamma%> does not depend on <%x%>. These independence constraints are omitted for the sake of readability. Apart from the dependencies between bindings in the context, the context is not assumed to have a particular ordering. In particular, the context does not have a linear structure, in contrast with common practice in dependently typed natural deduction.
{let sep = `Mm 2. in
 
 figurerules ~label:f_wdll ~caption:"Weak dependent {muname}" [
   simple_block "Syntax" begin
     syntax [
       syntax_line `Term Rules.Syntax.(core@shift@multiplicative@additive@exponential);
       commands
     ]
   end;
   simple_block "Reduction" begin
     reduction Rules.Reduction.(core@shift@multiplicative@additive@exponential)
   end;
(*
   simple_block "Derived syntax" begin
     array [`L; symbsep $=$; `L] [
       array_line ["<%lambda x,t%>";"<%mu(x,alpha),<t|alpha>%>"];
       array_line ["<%t u%>"; "<%mu alpha, <t|(u,alpha)>%>"];
       array_line ["<%{1=t,2=u}%>"; "<%{mu(1.alpha),<t|alpha> , mu(2.alpha),<u|alpha>}%>"];
       array_line ["<%t.1%>"; "<%mu alpha,<t|1.alpha>%>"];
       array_line ["<%t.2%>"; "<%mu alpha,<t|2.alpha>%>"];
     ]
   end; *)
   block "Typing" [`C;`C] begin
     let open Rules.Typing.Dll0 in
         [
           block_line ~sep [ id ; cut ];
           block_line ~sep [ iddup ; mu ];
           block_line ~sep [ shiftn ; shiftp ; ];
           block_line ~sep [ pair ; copair ];
           block_line ~sep [ unit ; counit ];
           block_line ~sep [ iota1 ; case ];
           block_line ~sep [ iota2 ; empty];
           block_line ~sep [ zero ; emptycase ];
           block_line ~sep [ bang ; whynot ];
         ]
   end;
(*
   block "Derived typing rules" [`C;`C] begin
     let open Rules.Typing.Mall in
         [
           block_line ~sep [ lambda ; app ];
           block_line ~sep [ record ; pi1 ];
           block_line ~sep [ empty  ; pi2 ];
         ]
   end;
*)
 ]}

As a consequence of this presentation, values do not reference the linear variables which occur in their types. This is a form of uniformity which values have to conform to: in the types of values, term variables behave a little like the type variables of the Hindley-Milner type system.

Maybe surprisingly, as the only substitution occur in the premises of the tensor rule, the typing rules, in weak dependent {muname}, of linear {lambda}-abstraction and application correspond to standard rules for dependently typed {lambda}-calculus -- except linear.

Linear {lambda} abstraction <%lambda x,t%> which is defined, as before, as <%mu(x,alpha),<t|alpha>%> demonstrates the essential use of the typing context:
{let open Infer in displaymath begin
  rule ~label:parr
    [rule ~label:cutrule
        ["<%Xi;Gamma,x:A|-t:N%>" ;
         rule ~label:idrule
           ["<%Xi,Gamma,x:A|-N^~:Type%>"]
           "<%Xi; Gamma,x:A; alpha:N^~|-_v alpha : N^~%>"]
        "<%Xi;Gamma,x:A,alpha:N^~|- <t|alpha>%>"]
    "<%Xi;Gamma |- mu(x,alpha),<t|alpha> : PI x:A,N%>"
end}
The typing derivation of the application <%t u = mu alpha,<t|(u,alpha)>%> indeed performs a substitution in the body of <%PI x:A,N%>. The well-formedness conditions of types are omitted for brevity:
{let open Infer in displaymath begin
  rule ~label:mu
    [rule ~label:cutrule
        ["<%Xi;Gamma|-t:PI x:A,N%>" ; rule ~label:tensor ["<%Xi;Gamma;Delta|-_v u:A%>";rule ~label:idrule [] "<%Xi;Gamma;alpha:subst [u,x] N^~ |-_v alpha : subst [u,x] N^~%>"] "<%Xi;Gamma;Delta,alpha:subst [u,x] N^~|-_v (u,alpha):SIGMA x:A,N^~%>"]
        "<%Xi;Gamma,Delta,alpha:subst [u,x] N^~|- <t|(u,alpha)>%>"]
    "<%Xi;Gamma,Delta |- mu alpha, <t|(u,alpha)> : subst [u,x] N%>"
end}

Weak dependent {muname} is not very expressive, nonetheless the various implementations of {textsc"lf"} have demonstrated that this kind of dependent types can already be quite useful. Weak dependent {muname} gives a natural definition for a dependently typed {emph"linear"} {lambda}-calculus.

(* arnaud: typing rules for types *)

{subsection"Dependent elimination"~label:ss_depelim}

If weak dependent {muname} can encode dependently typed linear {lambda}-calculus, as it happens, this does not extend to regular {lambda}-calculus. This is because it lacks so-called dependent elimination. In the statement

{rule_ (`Mm 3.) (`Mm 3.)}


See Figure~{ref_ f_dll}. There is a special variable <%cv%>, which can appear in types when typing a computation, and corresponds to the value against which it will be cut. We use names such as <%Gamma_cv%>, to represent contexts which may have <%cv%> in their types.
{let sep = `Mm 2. in
 figurerules ~label:f_dll ~caption:"Dependent {muname} with dependent elimination" [
   simple_block "Syntax" begin
     syntax [
       syntax_line `Term Rules.Syntax.(core@shift@multiplicative@additive@exponential);
       commands
     ]
   end;
   simple_block "Reduction" begin
     reduction Rules.Reduction.(core@shift@multiplicative@additive@exponential)
   end;
(*
   simple_block "Derived syntax" begin
     array [`L; symbsep $=$; `L] [
       array_line ["<%lambda x,t%>";"<%mu(x,alpha),<t|alpha>%>"];
       array_line ["<%t u%>"; "<%mu alpha, <t|(u,alpha)>%>"];
       array_line ["<%{1=t,2=u}%>"; "<%{mu(1.alpha),<t|alpha> , mu(2.alpha),<u|alpha>}%>"];
       array_line ["<%t.1%>"; "<%mu alpha,<t|1.alpha>%>"];
       array_line ["<%t.2%>"; "<%mu alpha,<t|2.alpha>%>"];
     ]
   end; *)
   block "Typing" [`C;`C] begin
     let open Rules.Typing.Dll1 in
         [
           block_line ~sep [ id ; cut ];
           block_line ~sep [ iddup ; mu ];
           block_line ~sep [ shiftn ; shiftp ; ];
           block_line ~sep [ pair ; copair ];
           block_line ~sep [ unit ; counit ];
           block_line ~sep [ iota1 ; case ];
           block_line ~sep [ iota2 ; empty];
           block_line ~sep [ zero ; emptycase ];
           block_line ~sep [ bang ; whynot ];
         ]
   end;
(*
   block "Derived typing rules" [`C;`C] begin
     let open Rules.Typing.Mall in
         [
           block_line ~sep [ lambda ; app ];
           block_line ~sep [ record ; pi1 ];
           block_line ~sep [ empty  ; pi2 ];
         ]
   end;
*)
 ]}

Usual dependent pattern-matching.
{let open Infer in
displaymath begin
  rule ~label:parr
    [rule ~label:cutrule
        ["<%Xi;Gamma,x:A,y:B|- v : \(subst [(x,y),cv] N_cv\)%>";
         rule ~label:idrule[]"<%Xi;alpha:\(subst [(x,y),cv] N_cv\)^~|-_v alpha : \(subst [(x,y),cv] N_cv\)^~%>"]
        "<%Xi;Gamma,x:A,y:B,alpha:\(subst [(x,y),cv] N_cv\)^~|- < v | alpha >%>"]
    "<%Xi;Gamma,alpha:\(N_cv\)^~ |- mu(x,y), < v | alpha > : A^~`& B^~%>"
end}

Commutative cuts (see Section~{ref_ ss_optim}). Suppose, that <%N_cv%>, above, is <%\(C_cv\) -o N_cv%>. Then, for <%Xi;Gamma;Delta|-_v u:A<*>B%> and <%Xi;Gamma;Pi|-_v t : subst [u,cv] C_cv%>:(*arnaud: v'erifier les Theta-context de u et t*)
{displaymath"<%Xi;Gamma,Delta,Pi|-(mu alpha, <u|mu(x,y),<v|alpha>>) t:subst[u,cv]N_cv%>"}

Uniformity lemma: <%Xi;Theta;subst[u,cv] Gamma_cv |-_v t : subst[u,cv] A_cv%> implies <%Xi;Theta,Pi;subst[v,cv] Gamma_cv |-_v t : subst[v,cv] A_cv%>

It is equivalent to: <%mu alpha,<u|mu(x,y), <v|(t,alpha)>>%>. In Coq, commutative cuts are not well-typed. Term of the former shape are essential to the expressiveness of Coq. In dependent {muname}:
{tiny begin
 let open Infer in
 displaymath begin
   rule ~label:mu
     [rule ~label:cutrule
         ["<%Xi;Gamma;Delta|-_v u : A<*>B%>";
          rule ~label:parr
            [rule ~label:cutrule
                ["<%Xi;Gamma,x:A,y:B|- v : \(subst[(x,y),cv] C_cv\) -o \(subst[(x,y),cv] N_cv\)%>";
                 "<%Xi;Gamma,x:A,y:A;Pi,alpha:\(subst[(x,y),cv] N_cv\)^~|-_v (t,alpha) : X%>"]
                "<%Xi;Gamma,Pi,x:A,y:B,alpha:\(subst[(x,y),cv] N_cv\)^~|- <v|(t,alpha)>%>"]
            "<%Xi;Gamma,Pi,alpha:\(N_cv\)^~|- mu(x,y), <v|(t,alpha)> : A^~`&B^~%>"]
         "<%Xi;Gamma,Delta,Pi,alpha:\(subst[u,cv]N_cv\)^~|-<u|mu(x,y), <v|(t,alpha)>>%>"]
     "<%Xi;Gamma,Delta,Pi|-mu alpha,<u|mu(x,y), <v|(t,alpha)>> : subst[u,cv]N_cv%>"
 end
end}

Shorter problem: <%< t | mu alpha,<u|mu beta,<v|beta> > >%> vs <%< u | mu beta, <v|t>>%>

$"<%lambda |_x_|,t%>"="<%mu(|_x_|,alpha),<t|alpha>%>"="<%mu(beta,alpha), <beta|mu|_x_|, <t|alpha>>%>"$. Typing derivation:
{let open Infer in
 displaymath begin
   rule ~label:tensor
     [rule ~label:cutrule
         [rule~label:idrule[]"<%Xi;;beta:!A|-_v beta : !A%>";
          rule ~label:whynotrule
            ["<%Xi,x:A;alpha:subst [|_x_|,cv] \(N_cv\)^~|- <t|alpha>%>"]
            "<%Xi;alpha:\(N_cv\)^~|-mu|_x_|, <t|alpha> : ?A^~%>"]
         "<%Xi;beta:!A,alpha:subst [beta,cv] \(N_cv\)^~|-<beta|mu|_x_|, <t|alpha>>%>"]
     "<%Xi;|-mu(beta,alpha), <beta|mu|_x_|, <t|alpha>> : PI x:!A, subst[beta,cv]N_cv%>"
end}

"
