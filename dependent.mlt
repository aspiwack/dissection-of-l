##verbatim '%' = MuPlugin.mumode

open Prelude
open Extra




let d = "{section"Dependent types" ~label:s_dep}

Polarised {muname}, with its type-based distinction of values and computations, gives an answer to the question of what it means for type to have effects in them: the answer is, they should not exist. If we see the type <%PI x:A, N%> as a generalisation of the type <%A-oN%>, it is clear that <%x%> only stands for values.

The obvious limitation is that even pure computation are ostensibly forbidden in types, preventing proofs by computation which are quite popular in modern dependent-type-theory-based proof assistants~{cite"Boutin1997"}. Another, somewhat separate, issue which is not addressed in this last section is that of the computation {emph"of"} types, which would be necessary to prove, for instance, the equivalence of <%A<+>B%> and <%SIGMA x:1<+>1, <x|{ mu(1.()), A , mu(2.()), B } >%>. The latter will not even be a valid type.

Despite these limitation, this modest proposal for a dependently typed linear logic is already a fairly expressive logic which includes dependent elimination -- as described in Section~{ref_ ss_depelim}.

{subsection"Weak dependent types"}

A first approach to extend linear {muname} or polarised {muname} with dependent types is to leverage the remark that the duplicable context behaves like a natural deduction context. We could therefore define a dependent product <%PI x:A,N%> like in natural deduction. This dependent product would generalise <%!A-oN%> and we would retain a separate, non-dependent, linear arrow <%A-oN%>. Such a system would be along the lines of linear {textsc"lf"}~{cite"Cervesato1996"}, except in sequence calculus form rather than a natural deduction.

There are no particular difficulty with this approach, but it has severe limitations. The most important limitation is that such a system cannot be extended to dependent elimination. The system we propose in this section has a dependent product which generalises the linear arrow. In Section~{ref_ ss_depelim}, we enrich it with dependent elimination.

A key point of our presentation of {muname} so far, is that <%mu alpha,<t|alpha>%> is essentially the same as just <%t%>, this underlies, in particular, our encoding of pattern-matching, and of linear {lambda}-calculus. This is problematic if types depend on linear variables. Indeed, if <%t%> has type <%N%>, which depend on some linear variable <%x%>, we need <%alpha%> to have type <%N^~%> which also depends on <%x%>. But variables have to be split between <%t%> and <%alpha%> so <%x%> can only go on one side of the cut.

This is where the polarised discipline helps: as variables represent only values, we can restrict type to contain values which are harmless in that they cannot perform effects by themselves. So, it is innocuous to allow variable duplication in types. In this proposal, it is manifested by a third context -- usually denoted by a <%theta%> -- in the typing judgement of value, which represents variables accessible from the type, but not from the value.

This new typing context affects principally the identity and cut rules. Indeed another way one can think about the typing context is that it allows variables to have any type.
{displaymath begin array [`C;`Sep(qquad^^qquad);`C] [
  array_line [ Rules.Typing.Dll0.id ; Rules.Typing.Dll0.cut ];
 ]end}
In the cut rule, the variables which are necessary to make sense of the types in <%Gamma%> and <%A%> but occur in the computation <%u%> are kept in the typing context of the value <%t%>. In the identity rule, the typing context and the duplicable context are joined to check the type is well-formed: types do not make a difference between linear and duplicable variables.

The full system is given in Figure~{ref_ f_wdll}. It makes the simplifying hypothesis that the type of duplicable variables does not depend on linear variables. When we write $"<%Gamma%>","<%Delta%>"$, it is implied that types in <%Delta%> may depend on variables of <%Gamma%> but types of <%Gamma%> may not depend on variables of <%Delta%>. Also, all context which appear in the premise of a typing rule is supposed to make sense, hence in the cut and tensor rule, it is understood that <%Gamma%> and <%Delta%> do not depend on each other, and in the introduction rule for <%?A^~%>, <%Gamma%> does not depend on <%x%>.

As a consequence of this presentation, values do not reference the linear variable which occur in their types. In that sense, values are uniform with respect to type dependencies.

{rule_ (`Mm 3.) (`Mm 3.)}

See Figure~{ref_ f_wdll}. Can encode dependently typed {lambda}-calculus.

{let sep = `Mm 2. in
 
 figurerules ~label:f_wdll ~caption:"Weak dependent {muname}" [
   simple_block "Syntax" begin
     syntax [
       syntax_line `Term Rules.Syntax.(core@shift@multiplicative@additive@exponential);
       commands
     ]
   end;
   simple_block "Reduction" begin
     reduction Rules.Reduction.(core@shift@multiplicative@additive@exponential)
   end;
(*
   simple_block "Derived syntax" begin
     array [`L; symbsep $=$; `L] [
       array_line ["<%lambda x,t%>";"<%mu(x,alpha),<t|alpha>%>"];
       array_line ["<%t u%>"; "<%mu alpha, <t|(u,alpha)>%>"];
       array_line ["<%{1=t,2=u}%>"; "<%{mu(1.alpha),<t|alpha> , mu(2.alpha),<u|alpha>}%>"];
       array_line ["<%t.1%>"; "<%mu alpha,<t|1.alpha>%>"];
       array_line ["<%t.2%>"; "<%mu alpha,<t|2.alpha>%>"];
     ]
   end; *)
   block "Typing" [`C;`C] begin
     let open Rules.Typing.Dll0 in
         [
           block_line ~sep [ id ; cut ];
           block_line ~sep [ iddup ; mu ];
           block_line ~sep [ shiftn ; shiftp ; ];
           block_line ~sep [ pair ; copair ];
           block_line ~sep [ unit ; counit ];
           block_line ~sep [ iota1 ; case ];
           block_line ~sep [ iota2 ; empty];
           block_line ~sep [ zero ; emptycase ];
           block_line ~sep [ bang ; whynot ];
         ]
   end;
(*
   block "Derived typing rules" [`C;`C] begin
     let open Rules.Typing.Mall in
         [
           block_line ~sep [ lambda ; app ];
           block_line ~sep [ record ; pi1 ];
           block_line ~sep [ empty  ; pi2 ];
         ]
   end;
*)
 ]}

Typing derivation for $"<%lambda x,t%>"="<%mu(x,alpha),<t|alpha>%>"$:
{let open Infer in displaymath begin
  rule ~label:parr
    [rule ~label:cutrule
        ["<%Xi;Gamma,x:A|-t:B^~%>" ; rule ~label:idrule [] "<%Xi; Gamma,x:A; alpha:B|-_v alpha : B%>"]
        "<%Xi;Gamma,x:A,alpha:B|- <t|alpha>%>"]
    "<%Xi;Gamma |- mu(x,alpha),<t|alpha> : PI x:A,B^~%>"
end}

(* Typing derivation for $"<%lambda |_x_|,t%>"="<%mu(|_x_|,alpha),<t|alpha>%>"$: *)
(* arnaud: 'ecrire proprement les r`egles des patterns dans le cas d'ependant *)
(* arnaud: does the type even work? I'm pretty sure it's silly*)
(* {let open Infer in displaymath begin *)
(*   rule ~label:parr *)
(*     [rule ~label:(cutp"<%(|_x_|,alpha)%>") *)
(*         ["<%Xi,x:A;Gamma|-t:B^~%>" ; rule ~label:idrule [] "<%Xi,x:A; alpha:B|-_v alpha : B%>"] *)
(*         "<%Xi,x:A;Gamma;alpha:B|- <t|alpha>%>"] *)
(*     "<%Xi;Gamma |- mu(|_x_|,alpha),<t|alpha> : PI x:!A,B^~%>" *)
(* end} *)

Typing derivation for $"<%t u%>"="<%mu alpha,<t|(u,alpha)>%>"$:
{let open Infer in displaymath begin
  rule ~label:mu
    [rule ~label:cutrule
        ["<%Xi;Gamma|-t:PI x:A,N%>" ; rule ~label:tensor ["<%Xi;Gamma;Delta|-_v u:A%>";rule ~label:idrule [] "<%Xi;Gamma;alpha:subst [u,x] N^~ |-_v alpha : subst [u,x] N^~%>"] "<%Xi;Gamma;Delta,alpha:subst [u,x] N^~|-_v (u,alpha):SIGMA x:A,N^~%>"]
        "<%Xi;Gamma,Delta,alpha:subst [u,x] N^~|- <t|(u,alpha)>%>"]
    "<%Xi;Gamma,Delta |- mu alpha, <t|(u,alpha)> : subst [u,x] N%>"
end}

{subsection"Dependent elimination"~label:ss_depelim}

See Figure~{ref_ f_dll}. There is a special variable <%cv%>, which can appear in types when typing a computation, and corresponds to the value against which it will be cut. We use names such as <%Gamma_cv%>, to represent contexts which may have <%cv%> in their types.
{let sep = `Mm 2. in
 figurerules ~label:f_dll ~caption:"Dependent {muname} with dependent elimination" [
   simple_block "Syntax" begin
     syntax [
       syntax_line `Term Rules.Syntax.(core@shift@multiplicative@additive@exponential);
       commands
     ]
   end;
   simple_block "Reduction" begin
     reduction Rules.Reduction.(core@shift@multiplicative@additive@exponential)
   end;
(*
   simple_block "Derived syntax" begin
     array [`L; symbsep $=$; `L] [
       array_line ["<%lambda x,t%>";"<%mu(x,alpha),<t|alpha>%>"];
       array_line ["<%t u%>"; "<%mu alpha, <t|(u,alpha)>%>"];
       array_line ["<%{1=t,2=u}%>"; "<%{mu(1.alpha),<t|alpha> , mu(2.alpha),<u|alpha>}%>"];
       array_line ["<%t.1%>"; "<%mu alpha,<t|1.alpha>%>"];
       array_line ["<%t.2%>"; "<%mu alpha,<t|2.alpha>%>"];
     ]
   end; *)
   block "Typing" [`C;`C] begin
     let open Rules.Typing.Dll1 in
         [
           block_line ~sep [ id ; cut ];
           block_line ~sep [ iddup ; mu ];
           block_line ~sep [ shiftn ; shiftp ; ];
           block_line ~sep [ pair ; copair ];
           block_line ~sep [ unit ; counit ];
           block_line ~sep [ iota1 ; case ];
           block_line ~sep [ iota2 ; empty];
           block_line ~sep [ zero ; emptycase ];
           block_line ~sep [ bang ; whynot ];
         ]
   end;
(*
   block "Derived typing rules" [`C;`C] begin
     let open Rules.Typing.Mall in
         [
           block_line ~sep [ lambda ; app ];
           block_line ~sep [ record ; pi1 ];
           block_line ~sep [ empty  ; pi2 ];
         ]
   end;
*)
 ]}

Usual dependent pattern-matching.
{let open Infer in
displaymath begin
  rule ~label:parr
    [rule ~label:cutrule
        ["<%Xi;Gamma,x:A,y:B|- v : \(subst [(x,y),cv] N_cv\)%>";
         rule ~label:idrule[]"<%Xi;alpha:\(subst [(x,y),cv] N_cv\)^~|-_v alpha : \(subst [(x,y),cv] N_cv\)^~%>"]
        "<%Xi;Gamma,x:A,y:B,alpha:\(subst [(x,y),cv] N_cv\)^~|- < v | alpha >%>"]
    "<%Xi;Gamma,alpha:\(N_cv\)^~ |- mu(x,y), < v | alpha > : A^~`& B^~%>"
end}

Commutative cuts (see Section~{ref_ ss_optim}). Suppose, that <%N_cv%>, above, is <%\(C_cv\) -o N_cv%>. Then, for <%Xi;Gamma;Delta|-_v u:A<*>B%> and <%Xi;Gamma;Pi|-_v t : subst [u,cv] C_cv%>:(*arnaud: v'erifier les Theta-context de u et t*)
{displaymath"<%Xi;Gamma,Delta,Pi|-(mu alpha, <u|mu(x,y),<v|alpha>>) t:subst[u,cv]N_cv%>"}

Uniformity lemma: <%Xi;Theta;subst[u,cv] Gamma_cv |-_v t : subst[u,cv] A_cv%> implies <%Xi;Theta,Pi;subst[v,cv] Gamma_cv |-_v t : subst[v,cv] A_cv%>

It is equivalent to: <%mu alpha,<u|mu(x,y), <v|(t,alpha)>>%>. In Coq, commutative cuts are not well-typed. Term of the former shape are essential to the expressiveness of Coq. In dependent {muname}:
{tiny begin
 let open Infer in
 displaymath begin
   rule ~label:mu
     [rule ~label:cutrule
         ["<%Xi;Gamma;Delta|-_v u : A<*>B%>";
          rule ~label:parr
            [rule ~label:cutrule
                ["<%Xi;Gamma,x:A,y:B|- v : \(subst[(x,y),cv] C_cv\) -o \(subst[(x,y),cv] N_cv\)%>";
                 "<%Xi;Gamma,x:A,y:A;Pi,alpha:\(subst[(x,y),cv] N_cv\)^~|-_v (t,alpha) : X%>"]
                "<%Xi;Gamma,Pi,x:A,y:B,alpha:\(subst[(x,y),cv] N_cv\)^~|- <v|(t,alpha)>%>"]
            "<%Xi;Gamma,Pi,alpha:\(N_cv\)^~|- mu(x,y), <v|(t,alpha)> : A^~`&B^~%>"]
         "<%Xi;Gamma,Delta,Pi,alpha:\(subst[u,cv]N_cv\)^~|-<u|mu(x,y), <v|(t,alpha)>>%>"]
     "<%Xi;Gamma,Delta,Pi|-mu alpha,<u|mu(x,y), <v|(t,alpha)>> : subst[u,cv]N_cv%>"
 end
end}

Shorter problem: <%< t | mu alpha,<u|mu beta,<v|beta> > >%> vs <%< u | mu beta, <v|t>>%>

"
